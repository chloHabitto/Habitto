import Foundation

// MARK: - Version Skipping Tests
// Tests migration jumps to verify all intermediate steps execute deterministically

class VersionSkippingTests {
    
    // MARK: - Custom Assertions (matching existing test infrastructure)
    
    private func assertEqual<T: Equatable>(_ actual: T, _ expected: T, _ message: String) {
        if actual != expected {
            print("‚ùå Assertion failed: \(message). Expected: \(expected), Actual: \(actual)")
        } else {
            print("‚úÖ \(message): \(expected)")
        }
    }
    
    private func assertTrue(_ condition: Bool, _ message: String) {
        if !condition {
            print("‚ùå Assertion failed: \(message)")
        } else {
            print("‚úÖ \(message)")
        }
    }
    
    // MARK: - Test Data Setup
    
    private var testHabits: [Habit] = []
    
    func setUp() {
        createTestHabits()
    }
    
    func tearDown() {
        testHabits = []
        cleanupTestData()
    }
    
    private func createTestHabits() {
        print("üîÑ Creating test habits for v1‚Üív4 migration test...")
        
        let testHabit1 = Habit(
            id: UUID(),
            name: "Read for 30 minutes",
            description: "Daily reading habit",
            icon: "üìö",
            color: .blue,
            habitType: .formation,
            schedule: "daily",
            goal: "30 minutes",
            reminder: "",
            startDate: Date(),
            endDate: nil,
            createdAt: Date(),
            reminders: [],
            baseline: 0,
            target: 30,
            completionHistory: [:],
            difficultyHistory: [:],
            actualUsage: [:]
        )
        
        let testHabit2 = Habit(
            id: UUID(),
            name: "Exercise regularly",
            description: "Physical activity",
            icon: "üèÉ‚Äç‚ôÇÔ∏è",
            color: .green,
            habitType: .formation,
            schedule: "3x per week",
            goal: "45 minutes",
            reminder: "Morning workout",
            startDate: Calendar.current.date(byAdding: .day, value: -7, to: Date()) ?? Date(),
            endDate: nil,
            createdAt: Calendar.current.date(byAdding: .day, value: -7, to: Date()) ?? Date(),
            reminders: [],
            baseline: 0,
            target: 45,
            completionHistory: ["2024-12-20": 1, "2024-12-21": 1, "2024-12-22": 1],
            difficultyHistory: [:],
            actualUsage: [:]
        )
        
        testHabits = [testHabit1, testHabit2]
        print("‚úÖ Created \(testHabits.count) test habits")
    }
    
    private func cleanupTestData() {
        // Clean up any test artifacts
        print("üßπ Cleaning up test data...")
        
        // Reset migration flags for testing
        let keys = [
            "AddHabitCreationDateMigrationCompleted",
            "NormalizeHabitGoalMigrationCompleted", 
            "CleanUpInvalidDataMigrationCompleted",
            "UserDefaultsToCoreDataMigrationCompleted",
            "CoreDataToCloudKitMigrationCompleted",
            "OptimizeUserDefaultsStorageMigrationCompleted"
        ]
        
        for key in keys {
            UserDefaults.standard.removeObject(forKey: key)
        }
        
        // Reset migration version for test independence
        UserDefaults.standard.removeObject(forKey: "DataMigrationVersion")
        UserDefaults.standard.set("1.0.0", forKey: "DataMigrationVersion")
        
        print("‚úÖ Test cleanup completed")
    }
    
    // MARK: - Main Version Skipping Test
    
    func testVersionSkipping_v1_to_v4_applies_all_steps() async throws {
        print("üß™ Testing version skipping v1.0.0 ‚Üí v4.0.0 migration...")
        
        setUp()
        
        let store = CrashSafeHabitStore.shared
        let migrationManager = await DataMigrationManager.shared
        
        // Step 1: Save initial data in v1 format
        print("üìä Setting up v1 payload...")
        try await store.saveHabits(testHabits)
        assertTrue(testHabits.count == 2, "Initial habits created")
        
        // Step 2: Simulate funding a v1 payload (old format)
        // Force setting migration version to simulate app restart from very old version
        UserDefaults.standard.set("1.0.0", forKey: "DataMigrationVersion")
        
        // Step 3: Load "upgrade to current"
        let migrationLogBefore = getMigrationLog()
        print("üîç Migration log before: \(migrationLogBefore.count) entries")
        
        // Step 4: Execute migration 
        print("üîÑ Executing migration from v1 ‚ûú v4...")
        do {
            try await migrationManager.executeMigrations()
            print("‚úÖ Migration executed successfully")
        } catch {
            print("‚ùå Migration failed: \(error)")
            throw error
        }
        
        // Step 5: Verify v4 format
        let loadedHabits = await store.loadHabits()
        assertEqual(loadedHabits.count, testHabits.count, "Habit count preserved after v1‚Üív4")
        
        // Step 6: Check migration log
        let migrationLogAfter = getMigrationLog()
        print("üîç Migration log after: \(migrationLogAfter.count) entries")
        
        // Expected migration steps should have been executed:
        let expectedSteps = [
            "Add Habit Creation Date",           // v1.1.0
            "Normalize Habit Goal",               // v1.2.0  
            "Clean Up Invalid Data",              // v1.3.0
            "Add Habit Creation Date",           // v1.1.0 (repeat due to conflicts)
            "Normalize Habit Goal",               // v1.2.0 (repeat)
            // May include storage-level migrations depending on infrastructure
        ]
        
        // Verify all intermediate steps were executed
        assertTrue(migrationLogAfter.count >= expectedSteps.count, "Should have at least \(expectedSteps.count) migration steps")
        
        // Step 7: Verify idempotence - run migration again
        print("üîÑ Testing migration idempotence...")
        try await migrationManager.executeMigrations()
        
        let migrationLogAfterIdempotence = getMigrationLog()
        let migrationCountChange = migrationLogAfterIdempotence.count - migrationLogAfter.count
        assertTrue(migrationCountChange == 0, "Migration should be idempotent (no new migrations)")
        
        // Step 8: Verify invariants pass
        print("üîç Checking storage invariants...")
        guard let verifyData = try? Data(contentsOf: getMainStorageURL()),
              let verifyContainer = try? JSONDecoder().decode(HabitDataContainer.self, from: verifyData) else {
            print("‚ùå Failed to verify storage invariants")
            throw TestError.verificationFailed
        }
        
        assertTrue(verifyContainer.version.count > 0, "Payload version should be updated")
        print("‚úÖ Invariants verification passed")
        
        print("üéâ Version skipping test completed successfully!")
        
        tearDown()
    }
    
    // MARK: - Helper Methods
    
    private func getMigrationLog() -> [MigrationLogEntry] {
        guard let data = UserDefaults.standard.data(forKey: "MigrationLog"),
              let log = try? JSONDecoder().decode([MigrationLogEntry].self, from: data) else {
            return []
        }
        return log
    }
    
    private func getMainStorageURL() -> URL {
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        return documentsPath.appendingPathComponent("HabitStorage.json")
    }
    
    // MARK: - Data Model Helpers
    
    private struct HabitDataContainer: Codable {
        let version: String
        let habits: [Habit]
        let creationDate: Date?
    }
    
    private enum TestError: Error {
        case verificationFailed
    }
    
    // MARK: - Main Test Runner
    
    func runTests() async {
        print("üöÄ Starting Version Skipping Tests...")
        
        do {
            try await testVersionSkipping_v1_to_v4_applies_all_steps()
            print("üéâ ALL TESTS PASSED")
        } catch {
            print("‚ùå TEST FAILED: \(error)")
        }
    }
}

// MARK: - Extensions for compatibility

extension VersionSkippingTests {
    /// Convenience method to use existing test runner pattern
    static func runAllTests() async {
        let testSuite = VersionSkippingTests()
        await testSuite.runTests()
    }
}

// MARK: - Integration with test command

extension VersionSkippingTests {
    /// Static entrance point for testing
    /// Usage:
    /// ```
    /// await VersionSkippingTests.runAllTests()
    /// ```
}
